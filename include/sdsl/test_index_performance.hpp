/* sdsl - succinct data structures library
    Copyright (C) 2010 Simon Gog

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see http://www.gnu.org/licenses/ .
*/
/*! \file test_index_performance.hpp
 *  \brief test_index_performance.hpp contains a set of benchmark methods
 *  \author Simon Gog
 */
#ifndef INCLUDE_SDSL_TEST_INDEX_PERFORMANCE
#define INCLUDE_SDSL_TEST_INDEX_PERFORMANCE

#include "int_vector.hpp"	// for bit_vector and int_vector
#include "util.hpp"			// for 
#include "algorithms.hpp"	// for backward_search
#include <cstdlib>			// for rand 
#include <algorithm>		// for swap
#include <vector>			// for std::vector	
#include <iostream>

namespace sdsl
{

// TODO: combine all random_access_tests and random_inverse_access  tests
//	     to two generic test cases
// split pre computation and measurement

//! Create 2^{log_s} random integers mod m with seed x
/*
 */
int_vector<64> get_rnd_positions(uint8_t log_s, uint64_t& mask, uint64_t m=0, uint64_t x=17);

//! Performs random accesses on a vector and returns the sum of the accessed elements
/*! \param v     The container.
 *  \param rands Vector of locations which should be accessed. Length is a power of 2.
 *               Can be generated by method: get_rnd_positions(log s, mask, v.size())
 *  \param mask  Mask which is used to perform the modulo s operation. See `rands`.
 *  \param times Number of iterations. If times > rands.size() array rands will be
 *               run through several times.
 */
template<class t_vec>
uint64_t test_random_access(const t_vec& v, const int_vector<64>& rands, uint64_t mask, uint64_t times=100000000)
{
    uint64_t cnt=0;
    for (uint64_t i=0; i<times; ++i) {
        cnt += v[rands[ i&mask ]];
    }
    return cnt;
}

template<class t_vec>
uint64_t test_inv_random_access(const t_vec& v, const int_vector<64>& rands, uint64_t mask, uint64_t times=100000000)
{
    uint64_t cnt=0;
    for (uint64_t i=0; i<times; ++i) {
        cnt += v(rands[ i&mask ]);
    }
    return cnt;
}

//! Perform random writes on a vector and return the sum of the written values.
/*! See test_random_access
 */
template<class t_vec>
uint64_t test_int_vector_random_write(t_vec& v, const int_vector<64>& rands, uint64_t mask, uint64_t times=100000000)
{
    uint64_t cnt=0;
    for (uint64_t i=0; i<times; ++i) {
        cnt += (v[rands[ i&mask ]] = i);
    }
    return cnt;
}

//! Perform `times` sequential write to a
template<class t_vec>
uint64_t test_int_vector_sequential_write(t_vec& v, uint64_t times=100000000)
{
    const uint64_t mask = (1ULL << bits::hi(v.size()))-1;
    uint64_t cnt=0;
    for (uint64_t i=0; i<times; ++i) {
        cnt += (v[i&mask] = i);
    }
    return cnt;
}

//! Test performance of the depth first iterator of a CST
/*!
 * \param cst The CST that should be tested.
 * \param times The number of times the depth first iterator should be incremented.
 * \par Details
 *      This method increments the depth first search iterator of
 *      a CST n times.
 */
template<class t_cst>
uint64_t test_cst_dfs_iterator(t_cst& cst, uint64_t times=100000)
{
    if (times > cst.nodes())
        times = cst.nodes();
    typename t_cst::const_iterator it = cst.begin();
    const typename t_cst::const_iterator end = cst.begin();
    for (uint64_t i=0; i<times; ++i) {
        if (it == end) it = cst.begin();
        ++it;
    }
    return it.visit();
}

//! Test performance of the depth first iterator and the LCP array of a CST
/*!
 * \param cst The CST that should be tested.
 * \param times The number of times the depth first iterator should be incremented.
 * \par Details
 *      This method increments the depth first search iterator of
 *      a CST n times and calculates the depth for each visited node.
 */
template<class t_cst>
uint64_t test_cst_dfs_iterator_and_depth(t_cst& cst, uint64_t times=1000000)
{
    uint64_t cnt=0;
    typename t_cst::const_iterator it = cst.begin();
    const typename t_cst::const_iterator end = cst.end();
    for (uint64_t i=0; i<times; ++i, ++it) {
        if (it == end) it = cst.begin();
        if (!cst.is_leaf(*it)) cnt += cst.depth(*it);
    }
    return cnt;
}

//! Test performance of the depth first iterator and the id method of the CST
/*!
 * \param cst The CST that should be tested.
 * \param times The number of times the depth first iterator should be incremented.
 * \par Details
 *      This method increments the depth first search iterator of
 *      a CST n times and calculates the function id for each visited node.
 */
template<class t_cst>
uint64_t test_cst_dfs_iterator_and_id(t_cst& cst, uint64_t times=1000000)
{
    uint64_t cnt=0;
    typename t_cst::const_iterator it = cst.begin();
    const typename t_cst::const_iterator end = cst.end();
    for (uint64_t i=0; i<times; ++i, ++it) {
        if (it == end) it = cst.begin();
        cnt += cst.id(*it);
    }
    return cnt;
}


//! Generate nodes of a cst by applying the child operation to each of \f$times\f$ random leaves until we get to the root
/*!
 * \param t_cst The compressed suffix
 * \param times Number of random leaves
 * \param nodes Reference to a vector which will contain the generated nodes
 * \param x     Seed for the random number generator for the generation of the leaves
 */
template<class t_cst>
void generate_nodes_from_random_leaves(const t_cst& cst, uint64_t times, std::vector<typename t_cst::node_type>& nodes, uint64_t x=17)
{
    typedef typename t_cst::node_type node_type;
    std::mt19937_64 rng(x);
    uint64_t n = cst.csa.size();
    // generate nodes
    for (uint64_t i=0; i<times; ++i) {
        node_type p = cst.select_leaf(1+ (rng() % n));
        nodes.push_back(p);
        while (p != cst.root()) {
            p = cst.parent(p);
            nodes.push_back(p);
        }
    }
}


/*
//! Test the speed of the child operation
//\param t_cst The compressed suffix tree
//\param times Number of times a traversal from a random leaf to the root\
//             is started to collect nodes for which the child operation is performed.
template<class t_cst>
void test_cst_child_operation(const t_cst& cst, uint64_t times=5000, uint64_t x=17)
{
    typedef typename t_cst::node_type node_type;

    std::vector<node_type> nodes;
    generate_nodes_from_random_leaves(cst, times, nodes, x);
    // choose some chars for the text
    unsigned char* letters = new unsigned char[nodes.size()+1];
    for (uint64_t i=0; i<nodes.size(); ++i) {
        letters[i] = cst.csa.bwt[i];
    }

    node_type c;  // for child node
    uint64_t char_pos=0;
    uint64_t cnt=0;
    util::write_R_output("cst","child","begin",nodes.size(),cnt);
    for (uint64_t i=0; i<nodes.size(); ++i) {
        c = cst.child(nodes[i], letters[i], char_pos);
        if (c==cst.root())
            ++cnt;
    }
    util::write_R_output("cst","child","end",nodes.size(),cnt);
    delete [] letters;
}


//! Test the speed of the parent operation
//\param t_cst The compressed suffix tree
//\param times Number of times a traversal from a random leaf to the root\
//             is started to collect nodes for which the parent operation is performed.
template<class t_cst>
void test_cst_parent_operation(const t_cst& cst, uint64_t times=100000, uint64_t x=17)
{
    typedef typename t_cst::node_type node_type;

    std::mt19937_64 rng(x);
    uint64_t n = cst.csa.size();
    // take \f$ time \f$ random leaves
    std::vector<node_type> rand_leaf(times);
    for (uint64_t i=0; i<rand_leaf.size(); ++i) {
        rand_leaf[i] = cst.select_leaf(1+ (rng() % n));
    }

    node_type p;
    uint64_t cnt=0;
    util::write_R_output("cst","parent","begin",times,cnt);
    for (uint64_t i=0; i<times; ++i, ++cnt) {
        p = cst.parent(rand_leaf[i]);
        while (p != cst.root()) {
            p = cst.parent(p);
            ++cnt;
        }
    }
    util::write_R_output("cst","parent","end",times,cnt);
}



//! Test the speed of the 1th_child operation
//\param t_cst The compressed suffix tree
//\param times Number of times a traversal from a random leaf to the root\
//             is started to collect nodes for which the child operation is performed.
template<class t_cst>
void test_cst_1th_child_operation(const t_cst& cst, uint64_t times=1000000, uint64_t x=17)
{
    typedef typename t_cst::node_type node_type;

    std::vector<node_type> nodes;
    generate_nodes_from_random_leaves(cst, times, nodes, x);

    node_type c;  // for 1th_child node
    uint64_t cnt=0;
    util::write_R_output("cst","1th_child","begin",nodes.size(),cnt);
    for (uint64_t i=0; i<nodes.size(); ++i) {
        c = cst.select_child(nodes[i], 1);
        if (c==cst.root())
            ++cnt;
    }
    util::write_R_output("cst","1th_child","end",nodes.size(),cnt);
}

//! Test the speed of the sibling operation
//\param t_cst The compressed suffix tree
//\param times Number of times a traversal from a random leaf to the root\
//                is started to collect nodes for which the child operation is performed.
template<class t_cst>
void test_cst_sibling_operation(const t_cst& cst, uint64_t times=100000, uint64_t x=17)
{
    typedef typename t_cst::node_type node_type;

    std::vector<node_type> nodes;
    generate_nodes_from_random_leaves(cst, times, nodes, x);
    for (uint64_t i=0; i<nodes.size(); ++i) {
        nodes[i] = cst.sibling(nodes[i]);
    }

    node_type c;  // for sibling node
    uint64_t cnt=0;
    util::write_R_output("cst","sibling","begin",nodes.size(),cnt);
    for (uint64_t i=0; i<nodes.size(); ++i) {
        c = cst.sibling(nodes[i]);
        if (c==cst.root())
            ++cnt;
    }
    util::write_R_output("cst","sibling","end",nodes.size(),cnt);
}

//! Test id operation
template<class t_cst>
void test_cst_id_operation(const t_cst& cst, uint64_t times=100000, uint64_t x=17)
{
    typedef typename t_cst::node_type node_type;
    std::vector<node_type> nodes;
    generate_nodes_from_random_leaves(cst, times, nodes, x);

    uint64_t cnt = 0;
    util::write_R_output("cst","id","begin",nodes.size(),cnt);
    for (uint64_t i=0; i < nodes.size(); ++i) {
        cnt += cst.id(nodes[i]);
    }
    util::write_R_output("cst","id","end",nodes.size(),cnt);
}

//! Test depth operations for leaves and inner nodes
template<class t_cst>
void test_cst_depth_operation(const t_cst& cst, uint64_t times=100000, uint64_t x=17)
{
    typedef typename t_cst::node_type node_type;
    std::vector<node_type> nodes;
    generate_nodes_from_random_leaves(cst, times, nodes, x);

    uint64_t cnt = 0;
    util::write_R_output("cst","depth","begin",nodes.size(),cnt);
    for (uint64_t i=0; i < nodes.size(); ++i) {
        cnt += cst.depth(nodes[i]);
    }
    util::write_R_output("cst","depth","end",nodes.size(),cnt);
}


//! Test depth operations for inner nodes
template<class t_cst>
void test_cst_depth_operation_for_inner_nodes(const t_cst& cst, uint64_t times=100000, uint64_t x=17)
{
    typedef typename t_cst::node_type node_type;
    std::vector<node_type> nodes;
    {
        std::vector<node_type> nodes2;
        generate_nodes_from_random_leaves(cst, times, nodes2, x);
        for (uint64_t i=0; i<nodes2.size(); ++i)
            if (!cst.is_leaf(nodes2[i])) {
                nodes.push_back(nodes2[i]);
            }
    }
    uint64_t cnt = 0;
    util::write_R_output("cst","depth of inner nodes","begin",nodes.size(),cnt);
    for (uint64_t i=0; i < nodes.size(); ++i) {
        cnt += cst.depth(nodes[i]);
    }
    util::write_R_output("cst","depth of inner nodes","end",nodes.size(),cnt);
}

//! Test lca operation
template<class t_cst>
void test_cst_lca_operation(const t_cst& cst, uint64_t times=1000000, uint64_t x=17)
{
    typedef typename t_cst::node_type node_type;
    // 	generate \f$2^{19}\f$ random pairs of leafs
    uint64_t n = cst.csa.size();
    uint64_t mask = (1<<20)-1;
    std::vector<node_type> nodes(1<<20);
    std::mt19937_64 rng(x);
    for (uint64_t i=0; i < nodes.size(); ++i) {
        nodes[i] = cst.select_leaf(rng()%n + 1);
    }

    uint64_t cnt=0;
    util::write_R_output("cst","lca","begin",times,cnt);
    for (uint64_t i=0; i<times; ++i) {
        node_type v = cst.lca(nodes[(2*i) & mask], nodes[(2*i+1) & mask]);
        if (v == cst.root())
            cnt++;
    }
    util::write_R_output("cst","lca","end",times,cnt);
}

//! Test suffix link operation
template<class t_cst>
void test_cst_sl_operation(const t_cst& cst, uint64_t times=500, uint64_t x=17)
{
    typedef typename t_cst::node_type node_type;
    uint64_t n = cst.csa.size();
    if (times > n)
        times = n;

    std::vector<node_type> nodes(times);
    std::mt19937_64 rng(x);
    // take \f$ times \f$ random leaves and calculate each parent
    for (uint64_t i=0; i<times; ++i) {
        nodes[i] = cst.parent(cst.select_leaf(rng()%n + 1));
    }

    uint64_t cnt=0;
    times = 0;
    util::write_R_output("cst","sl","begin",0,cnt);
    for (uint64_t i=0; i<nodes.size(); ++i) {
        node_type v = nodes[i];
        while (v != cst.root()) { // while v is not the root
            ++cnt;
            v = cst.sl(v); // follow suffix link
        }
    }
    util::write_R_output("cst","sl","end",cnt,cnt);
}

//! Test matching statistics
// \param cst	Compressed suffix tree of sequence S1 of length n1
//  \param S2	Pointer to the unsigned char array S2.
//  \param n2	The length of S2.
//
template<class t_cst>
void test_cst_matching_statistics(const t_cst& cst, unsigned char* S2, uint64_t n2)
{
    typedef typename t_cst::node_type node_type;

    uint64_t cnt = 0;
    uint64_t q  = 0;						// current match length
    uint64_t p2 = n2-1;              // position in S2
    uint64_t i  = 0, j = cst.csa.size()-1; // \f$ \epsilon \f$ matches all suffixes of S1
    while (p2+1 > 0) {
        uint64_t lb, rb;
        // perform backward search on interval \f$ [i,j] \f$
        uint64_t size = algorithm::backward_search(cst.csa, i, j, S2[p2], lb, rb);
        if (size > 0) {
            q = q + 1;
            i = lb; j = rb;
            p2 = p2 - 1;
        } else if (i==0 and j == cst.csa.size()) {
            p2 = p2 -1;
        } else {
            // map interval to a node of the cst and calculate parent
            node_type p = cst.parent(cst.node(i, j));
            q = cst.depth(p);	// update match length
            i = cst.lb(p); 		// update left bound
            j = cst.rb(p);		// update right bound
        }
        cnt += q;
    }
}

// test the speed of find_close at random opening parentheses
template<class Bps>
void test_bps_find_close_and_enclose(const Bps& bps, const bit_vector& b, uint64_t times=10000000, uint64_t x=17)
{

    uint64_t mask;
//	uint64_t n = bps.size();
    int_vector<64> rands = get_rnd_positions(20, mask, bps.size());
    for (uint64_t i=0; i<rands.size(); ++i) {
        if (!b[rands[i]]) { // if there is no opening parentheses at position rands[i]
            rands[i] = bps.find_open(rands[i]);
        }
    }
    uint64_t cnt = 0;
    util::write_R_output("bps","find_close","begin",times, cnt);
    for (uint64_t i=0; i<times; ++i) {
        cnt += bps.find_close(rands[i&mask]);
    }
    util::write_R_output("bps","find_close","end",times, cnt);

    cnt = 0;
    util::write_R_output("bps","enclose rand","begin",times, cnt);
    for (uint64_t i=0; i<times; ++i) {
        cnt += bps.enclose(rands[i&mask]);
    }
    util::write_R_output("bps","enclose rand","end",times, cnt);

    cnt = 0;
    uint64_t cnt2=0;
    util::write_R_output("bps","enclose tree","begin",times, cnt);
    for (uint64_t i=0,enc, size=bps.size(); cnt2 < times; ++i) {
        enc = rands[i&mask];
        while ((enc = bps.enclose(enc)) != size) {
            cnt += enc;
            ++cnt2;
        }
        ++cnt2;
    }
    util::write_R_output("bps","enclose tree","end",times, cnt);
}

// test the speed of find_close at random opening parentheses
template<class Bps>
void test_bps_find_open(const Bps& bps, const bit_vector& b, uint64_t times=10000000, uint64_t x=17)
{
    uint64_t mask;
    uint64_t n = bps.size();
    int_vector<64> rands = get_rnd_positions(20, mask, n);
    for (uint64_t i=0; i<rands.size(); ++i) {
        if (b[rands[i]]) {
            rands[i] = bps.find_close(rands[i]);
        }
    }
    uint64_t cnt = 0;
    util::write_R_output("bps","find_open","begin",times, cnt);
    for (uint64_t i=0; i<times; ++i) {
        cnt += bps.find_open(rands[i&mask]);
    }
    util::write_R_output("bps","find_open","end",times, cnt);
}

// test the speed of the double enclose method for random opening parentheses i and i+1
template<class Bps>
void test_bps_double_enclose(const Bps& bps, const bit_vector& b, uint64_t times=10000000, uint64_t x=17)
{
    uint64_t mask;
    uint64_t n = bps.size();
    int_vector<64> rands = get_rnd_positions(20, mask, bps.size());
    for (uint64_t i=0; i<rands.size()/2; ++i) {
        if (!b[rands[2*i]]) { // if there is no opening parentheses at position rands[i]
            uint64_t pos = (rands[2*i]+1)%n;
            while (!b[pos] and pos != rands[2*i])  // go forward until we get an opening one
                pos = (pos+1) % n;
            if (pos + 1000 > rands.size())
                pos = 0;
            rands[2*i] = pos;
        }
        {
            uint64_t pos = (rands[2*i]+1)%n;
            while (!b[pos] and pos != rands[2*i])  // go forward until we get the next opening one
                pos = (pos+1) % n;
            rands[2*i+1] = pos;
        }
    }
    uint64_t cnt = 0;
    util::write_R_output("bps","double_enclose","begin",times, cnt);
    for (uint64_t i=0; i<times; ++i) {
        cnt += bps.double_enclose(rands[(i*2)&mask], rands[(i*2+1)&mask]);
    }
    util::write_R_output("bps","double_enclose","end",times, cnt);
}
*/

}// end namespace sdsl

#endif
