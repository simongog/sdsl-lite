\documentclass[10pt,landscape]{article}
\usepackage{multicol}
\usepackage{calc}
\usepackage{ifthen}
\usepackage[landscape]{geometry}

\usepackage{amsmath} 
\usepackage[colorlinks]{hyperref}
% To make this come out properly in landscape mode, do one of the following
% 1.
%  pdflatex latexsheet.tex
%
% 2.
%  latex latexsheet.tex
%  dvips -P pdf  -t landscape latexsheet.dvi
%  ps2pdf latexsheet.ps


% If you're reading this, be prepared for confusion.  Making this was
% a learning experience for me, and it shows.  Much of the placement
% was hacked in; if you make it better, let me know...


% 2008-04
% Changed page margin code to use the geometry package. Also added code for
% conditional page margins, depending on paper size. Thanks to Uwe Ziegenhagen
% for the suggestions.

% 2006-08
% Made changes based on suggestions from Gene Cooperman. <gene at ccs.neu.edu>


% To Do:
% \listoffigures \listoftables
% \setcounter{secnumdepth}{0}


% This sets page margins to .5 inch if using letter paper, and to 1cm
% if using A4 paper. (This probably isn't strictly necessary.)
% If using another size paper, use default 1cm margins.
\ifthenelse{\lengthtest { \paperwidth = 11in}}
	{ \geometry{top=.5in,left=.5in,right=.5in,bottom=.5in} }
	{\ifthenelse{ \lengthtest{ \paperwidth = 297mm}}
		{\geometry{top=1cm,left=1cm,right=1cm,bottom=1cm} }
		{\geometry{top=1cm,left=1cm,right=1cm,bottom=1cm} }
	}

% Turn off header and footer
\pagestyle{empty}
 

% Redefine section commands to use less space
\makeatletter
\renewcommand{\section}{\@startsection{section}{1}{0mm}%
                                {-1ex plus -.5ex minus -.2ex}%
                                {0.5ex plus .2ex}%x
                                {\normalfont\large\bfseries}}
\renewcommand{\subsection}{\@startsection{subsection}{2}{0mm}%
                                {-1explus -.5ex minus -.2ex}%
                                {0.5ex plus .2ex}%
                                {\normalfont\normalsize\bfseries}}
\renewcommand{\subsubsection}{\@startsection{subsubsection}{3}{0mm}%
                                {-1ex plus -.5ex minus -.2ex}%
                                {1ex plus .2ex}%
                                {\normalfont\small\bfseries}}
\makeatother

% Define BibTeX command
\def\BibTeX{{\rm B\kern-.05em{\sc i\kern-.025em b}\kern-.08em
    T\kern-.1667em\lower.7ex\hbox{E}\kern-.125emX}}

% Don't print section numbers
\setcounter{secnumdepth}{0}


\setlength{\parindent}{0pt}
\setlength{\parskip}{0pt plus 0.5ex}

% -----------------------------------------------------------------------

\DeclareMathOperator*{\argmin}{arg\!\min}

\begin{document}
\newlength{\MyLen}
\newlength{\MidLen}

\raggedright
\footnotesize
\begin{multicols}{3}


% multicol parameters
% These lengths are set only within the two main columns
%\setlength{\columnseprule}{0.25pt}
\setlength{\premulticols}{1pt}
\setlength{\postmulticols}{1pt}
\setlength{\multicolsep}{1pt}
\setlength{\columnsep}{2pt}

\newcommand{\Order}[1]{\ensuremath{{\mathcal O}(#1)}}

\newcommand{\sdsl}{\ensuremath{\mathit{sdsl}}}
\newcommand{\sdslgit}{https://github.com/simongog/sdsl-lite/blob/master}
\newcommand{\code}[1]{\texttt{#1}}
%%% int vector representations
\newcommand{\sdslintvector}{\code{int\_vector}}
\newcommand{\sdslintvectorZ}{\code{int\_vector\textless\textgreater}}
\newcommand{\sdslencvector}{\code{enc\_vector}}
\newcommand{\sdslvlcvector}{\code{vlc\_vector}}
%%% coder 
\newcommand{\sdslcodereliasdelta}{\code{coder::elias\_delta}}
\newcommand{\sdslcoderfibonacci}{\code{coder::fibonacci}}
%%% bit vector representations
\newcommand{\sdslbitvector}{\code{bit\_vector}}
\newcommand{\sdslbitvectoril}{\code{bit\_vector\_il}}
\newcommand{\sdslrrrvector}{\code{rrr\_vector}}
\newcommand{\sdslsdvector}{\code{sd\_vector}}
%%%% rank support structures
\newcommand{\sdslranksupportv}{\code{rank\_support\_v}}
\newcommand{\sdslranksupportvV}{\code{rank\_support\_v5}}
\newcommand{\sdslranksupportil}{\code{rank\_support\_il}}
\newcommand{\sdslranksupportrrr}{\code{rank\_support\_rrr}}
\newcommand{\sdslranksupportsd}{\code{rank\_support\_sd}}
\newcommand{\sdslranksupportscan}{\code{rank\_support\_scan}}
%%%% select support structures
\newcommand{\sdslselectsupportmcl}{\code{select\_support\_mcl}}
\newcommand{\sdslselectsupportscan}{\code{select\_support\_scan}}
\newcommand{\sdslselectsupportil}{\code{select\_support\_il}}
\newcommand{\sdslselectsupportrrr}{\code{select\_support\_rrr}}
\newcommand{\sdslselectsupportsd}{\code{select\_support\_sd}}
%%%% WTs
\newcommand{\sdslwthuff}{\code{wt\_huff}}
\newcommand{\sdslwt}{\code{wt}}
\newcommand{\sdslwtint}{\code{wt\_int}}
\newcommand{\sdslwtrlmn}{\code{wt\_rlmn}}
%%%% CSAs
\newcommand{\sdslcsabitcompressed}{\code{csa\_bitcompressed}}
\newcommand{\sdslcsasada}{\code{csa\_sada}}
\newcommand{\sdslcsawt}{\code{csa\_wt}}
%%%% Alphabet strategy (policy parametrization see Stroustrup C++ 24.4.1)
\newcommand{\sdslbytealphabetstrategy}{\code{byte\_alphabet\_strategy}}
\newcommand{\sdslsuccinctbytealphabetstrategy}{\code{succinct\_byte\_alphabet\_strategy}}
\newcommand{\sdslintalphabetstrategy}{\code{int\_alphabet\_strategy}}
%%%% Alphabet strategy (policy parametrization see Stroustrup C++ 24.4.1)
\newcommand{\sdslsaordersasampling}{\code{sa\_order\_sa\_sampling}}
\newcommand{\sdsltextordersasampling}{\code{text\_order\_sa\_sampling}}

%%%% LCPs
\newcommand{\sdsllcpbitcompressed}{\code{lcp\_bitcompressed}}
\newcommand{\sdsllcpdac}{\code{lcp\_dac}}
\newcommand{\sdsllcpvlc}{\code{lcp\_vlc}}
\newcommand{\sdsllcpbyte}{\code{lcp\_byte}}
\newcommand{\sdsllcpsupportsada}{\code{lcp\_support\_sada}}
\newcommand{\sdsllcpwt}{\code{lcp\_wt}}
\newcommand{\sdsllcpsupporttree}{\code{lcp\_support\_tree}}
\newcommand{\sdsllcpsupporttreeII}{\code{lcp\_support\_tree2}}
%%%% PBSs
\newcommand{\sdslbpsupportg}{\code{bp\_support\_g}}
\newcommand{\sdslbpsupportgg}{\code{bp\_support\_gg}}
\newcommand{\sdslbpsupportsada}{\code{bp\_support\_sada}}
%%%% CSTs
\newcommand{\sdslcstsada}{\code{cst\_sada}}
\newcommand{\sdslcstsctIII}{\code{cst\_sct3}}
%%%% RMQs
\newcommand{\sdslrmqsupportsparsetable}{\code{rmq\_support\_sparse\_table}}
\newcommand{\sdslrmqsuccinctsada}{\code{rmq\_succint\_sada}}
\newcommand{\sdslrmqsuccinctsct}{\code{rmq\_succint\_sct}}

\begin{center}
     \Large{\textbf{\sdsl\ Cheat Sheet}} \\
\end{center}

\section{Data structures}
The library code is in the sdsl namespace. Either import
the namespace in your program (\code{using~namespace~sdsl;}) or
qualify all identifieres by a \code{sdsl::}-prefix.

We decide between two types of data structure in \sdsl.
The \emph{self-contained} and the \emph{support}
structures. A support object \code{s} can extend
a self-contained object \code{t} (e.g. add functionality), but 
needs access to \code{t}. 

\subsection{Unsigned Integer Vectors}
The core of the library is the class 
\href{\sdslgit/include/sdsl/int_vector.hpp}{\sdslintvector\textless$w$\textgreater}.
Parameter $w$ corresponds to the fixed length of each
element in bits.  For $w=8,16,32,64,1$ the length is
fixed during compile time and the vectors
correspond to \href{http://www.sgi.com/tech/stl/Vector.html}{\code{std::vector\textless uint$w$\_t\textgreater}}
resp. \code{std::vector<bool>}.
If $w=0$ (default) the length can be set during runtime.
\textit{Constructor:} \sdslintvectorZ\code{($n$, $x$, $\ell$)}, with 
$n$ equals size, $x$ default integer value, $\ell$ width
of integer (has no effect for $w>0$).

\textit{Public~methods:} \code{operator[i]}, \code{size()}, \code{width()}, 
\code{data()}. 

\subsubsection{Manipulating \sdslintvector\textless$w$\textgreater\ \code{v}}
\settowidth{\MyLen}{\code{util::set\_random\_bits(v)}\quad}
\begin{tabular}{@{}p{\the\MyLen}%
                @{}p{\linewidth-\the\MyLen}@{}}
\textit{Method}                     & \textit{Description} \\
\code{v[$i$]=$x$}                   & Set entry \code{v[$i$]} to $x$. \\
\code{v.width($\ell$)}	            & Set width to $\ell$, if $w=0$.\\
\code{v.resize($n$)}				& Resize $v$ to $n$ elements. \\
\code{util::set\_one\_bits(v)}      & Set elements of \code{v} to \code{1}. \\
\code{util::set\_zero\_bits(v)}     & Set elements of \code{v} to \code{0}. \\
\code{util::set\_to\_id(v)}         & Set \code{v[$i$]=$i$} for each $i$.\\
\code{util::set\_to\_value(v,$k$)} & Set \code{v[$i$]=$k$} for each $i$.\\
\code{util::set\_random\_bits(v)}   & Set elements to random bits. \\
\code{util::mod(v,$m$)}            & Set \code{v[$i$]=v[$i$]$\bmod m$} for each $i$.\\
\code{util::bit\_compress(v)}       & Determine \code{$x\!=\!\max_i$v[$i$]} and 
                                      $\ell\!=\!\lceil\log(x\!-\!1)\rceil\!+\!1$.  
                                      And pack the entries in $\ell$-bit integers.\\
%									  and call \code{v.width($\ell$)}.\\
\code{util::expand\_width(v, $\ell$)} & Expands the width of each integer to
										$\ell$ bits, if \code{$\ell\geq$~v.width()}\\
\end{tabular}

\subsection{Compressed Unsigned Integer Vector}
For a vector \code{v}, \href{\sdslgit/include/sdsl/enc_vector.hpp}{\sdslencvector} stores the
self-delimiting coded deltas (\code{v[$i\!+\!1$]$-$v[$i$]}). Fast random access is
achieved by sampling values of \code{v} at rate \code{t\_dens}. Available coder
are \href{\sdslgit/include/sdsl/coder_elias_delta.hpp}{\sdslcodereliasdelta} and
\href{\sdslgit/include/sdsl/coder_fibonacci.hpp}{\sdslcoderfibonacci}. 

TODO: describe 
\href{\sdslgit/include/sdsl/vlc_vector.hpp}{\sdslvlcvector} 

\subsection{Bitvectors (BV)}
Representations for a bitvector of length $n$ with $m$ set bits.
\begin{tabular}{@{}lll@{}}
\textit{Class}    & \textit{Description}       & \textit{Space}  \\
\href{\sdslgit/include/sdsl/int_vector.hpp}{\sdslbitvector} & 
plain bitvector            & 64$\lceil n/64\!+\!1\rceil$ \\
\href{\sdslgit/include/sdsl/bit_vector_il.hpp}{\sdslbitvectoril} &
interleaved  bitvector & $\approx n(1+K/64)$  \\
\href{\sdslgit/include/sdsl/rrr_vector.hpp}{\sdslrrrvector} & 
$H_0$-compressed bitvector & $\approx \lceil \log {m\choose n} \rceil$ \\
\href{\sdslgit/include/sdsl/sd_vector.hpp}{\sdslsdvector}  & sparse bitvector
& $\approx\ 2 m\cdot log\frac{n}{m}$ \\	
\end{tabular}
\sdslbitvector\ equals \sdslintvector\code{\textless1\textgreater} and
is therefore dynamic.\\
\textit{Public Methods:} \code{operator[]}, \code{size()}\\
\textit{Public Types:} \code{rank\_1\_type}, \code{select\_1\_type},
                       \code{select\_0\_type}\footnote{\code{select\_0\_type} not defined for \sdslsdvector.}.
Each bitvector can be constructed out of an
\sdslbitvector\ object.

\subsection{Rank Supports (RS)}
RS adds rank functionality to BV. Method
\code{rank($i$)} or \code{operator($i$)} returns the number
of set bits\footnote{It is also possible to rank \code{0} or
the patterns \code{10} and \code{01}.} in the prefix $[0..i)$ of the
supported BV for $i \in [0,n]$.
\begin{tabular}{@{}llll@{}}
\textit{Class}    & \textit{Compatible BV} & \textit{Space} & \textit{Time} \\
\href{\sdslgit/include/sdsl/rank_support_v.hpp}{\sdslranksupportv} &
\sdslbitvector & $0.25 n$ & \Order{1} \\
\href{\sdslgit/include/sdsl/rank_support_v5.hpp}{\sdslranksupportvV} &
\sdslbitvector & $0.0625 n$ & \Order{1} \\
\href{\sdslgit/include/sdsl/rank_support_scan.hpp}{\sdslranksupportscan} &
\sdslbitvector & 64 & \Order{n} \\
\href{\sdslgit/include/sdsl/rank_support_il.hpp}{\sdslranksupportil} &
\sdslbitvectoril & 128 & \Order{1} \\
\href{\sdslgit/include/sdsl/rrr_vector.hpp}{\sdslranksupportrrr} &
\sdslrrrvector & 80 & \Order{k} \\
\href{\sdslgit/include/sdsl/sd_vector.hpp}{\sdslranksupportsd} &
\sdslsdvector & 64 & \Order{1} \\
\end{tabular}
Call~\code{util::init\_support(rs, bv)}~to initialize rank
structure \code{rs} to bitvector \code{bv}. Call \code{rs($i$)} to get $\code{rank(}i\code{)}=\sum_{k=0}^{k<i}\code{bv[}k\code{]}$

\subsection{Select Supports (SS)}\label{sec-SS}
SS adds select functionality to BV. Let $m$ be the number of set bits
in BV. Method \code{select($i$)} or \code{operator($i$)} return the
position of the $i$-th set bit%
\footnote{It is also possible to select \code{0} or
the patterns \code{10} and \code{01}.}
in BV for \code{i}$\in [1..m]$.
\begin{tabular}{@{~}l@{~}l@{~~}p{9ex}l@{}}
\textit{Class}    &\textit{Compatible BV}           &\textit{Space}&\textit{Time}\\
\href{\sdslgit/include/sdsl/select_support_mcl.hpp}{\sdslselectsupportmcl} &
\sdslbitvector & $\leq\!0.2 n$ & \Order{1}\\
\href{\sdslgit/include/sdsl/select_support_scan.hpp}{\sdslselectsupportscan} &
\sdslbitvector & $64$ & \Order{n}\\
\href{\sdslgit/include/sdsl/select_support_il.hpp}{\sdslselectsupportil} &
\sdslbitvectoril & $64$ & \Order{\log n}\\
\href{\sdslgit/include/sdsl/rrr_select_support.hpp}{\sdslselectsupportrrr} &
\sdslrrrvector & $64$ & $\Order{\log n}$ \\
\href{\sdslgit/include/sdsl/sd_select_support.hpp}{\sdslselectsupportsd} &
\sdslsdvector & $64$ & \Order{1} \\
\end{tabular}
Call~\code{util::init\_support(ss, bv)}~to initialize \code{ss} 
to bitvector \code{bv}. Call \code{ss($i$)} to get
$\code{select(}i\code{)}=\min\{j\mid \code{rank(}j\!+\!1\code{)}=i\}$. 

\subsection{Wavelet Trees (WT)}
Mention: alphabet strategies
\begin{tabular}{@{}ll@{}}
\textit{Class}    &\textit{Description} \\
\href{\sdslgit/include/sdsl/wt_huff.hpp}{\sdslwthuff} &
Huffman shaped wavelet tree for byte alphabets.\\
\href{\sdslgit/include/sdsl/wt_int.hpp}{\sdslwtint} &
Complete wavelet tree for integer alphabets.\\
\href{\sdslgit/include/sdsl/wt.hpp}{\sdslwt} &
Complete wavelet tree for byte alphabets.\\
\href{\sdslgit/include/sdsl/wt_rlmn.hpp}{\sdslwtrlmn} &
Run-length compressed wavelet tree. 
                 %The run heads are stored in another WT and a bitvector
				 %is used to map between the domains.
				 \\ 
% TODO: \verb!wt_rlg!
\end{tabular}
\textit{Public~methods:} \code{operator[i]}, \code{rank(i, c)},
\code{select(i, c)}, \code{inverse\_select(i, c)}	\\

\subsection{Compressed Suffix Arrays (CSA)}
\begin{tabular}{@{}ll@{}}
\textit{Class}    &\textit{Description} \\
\href{\sdslgit/include/sdsl/csa_bitcompressed.hpp}{\sdslcsabitcompressed} &
Stores SA, ISA and C.\\
\href{\sdslgit/include/sdsl/csa_sada.hpp}{\sdslcsasada} &
Based on the compressed $\Psi$ function.\\
\href{\sdslgit/include/sdsl/csa_wt.hpp}{\sdslcsawt} &
Based on the WT of the texts BWT.\\
\end{tabular}	
\textit{Public~methods:} \code{operator[i]}, \code{operator(i)}, 
\code{rank\_bwt(i,c)}, \code{select\_bwt(i,c)}\\
\textit{Public~members:} \code{bwt}, \code{text}, 
\code{psi}\footnote{LF[i] is accessible by \code{operator(i)} of \code{psi}},
\code{C}, \code{char2comp}, \code{comp2char}, \code{sigma}.\\
\textit{Policy classes: } alphabet strategy 
(e.g.
\href{\sdslgit/include/sdsl/csa_alphabet_strategy}{\sdslbytealphabetstrategy},
\href{\sdslgit/include/sdsl/csa_alphabet_strategy}{\sdslsuccinctbytealphabetstrategy},
\href{\sdslgit/include/sdsl/csa_alphabet_strategy}{\sdslintalphabetstrategy})
and SA sampling strategy 
(e.g. 
 \href{\sdslgit/include/sdsl/csa_sampling_strategt}{\sdslsaordersasampling},
 \href{\sdslgit/include/sdsl/csa_sampling_strategt}{\sdsltextordersasampling}
)


\subsection{Longest Common Prefix (LCP) Arrays}
\begin{tabular}{@{}ll@{}}
\textit{Class}    &\textit{Description} \\
\href{\sdslgit/include/sdsl/lcp_bitcompressed.hpp}{\sdsllcpbitcompressed} &
\sdslintvectorZ.\\
\href{\sdslgit/include/sdsl/lcp_dac.hpp}{\sdsllcpdac} &
direct accessible code.\\
\href{\sdslgit/include/sdsl/lcp_byte.hpp}{\sdsllcpbyte} &
use byte or words dependent.\\
\href{\sdslgit/include/sdsl/lcp_wt.hpp}{\sdsllcpwt} &
store small values in a WT.\\
\href{\sdslgit/include/sdsl/lcp_vlc.hpp}{\sdsllcpvlc} &
uses self-delimiting code \\
\href{\sdslgit/include/sdsl/lcp_support_sada.hpp}{\sdsllcpsupportsada} &
store values permuted. CSA needed. \\
\href{\sdslgit/include/sdsl/lcp_support_tree.hpp}{\sdsllcpsupporttree} &
using tree topology.\\
\href{\sdslgit/include/sdsl/lcp_support_tree2.hpp}{\sdsllcpsupporttreeII} &
using tree topology and LF.\\
\end{tabular}	
\textit{Public~methods:} \code{operator[i]} \\

\subsection{Balanced Parentheses Support (BPS)}
An opening (closing) parenthesis is represented as 
\code{1} (\code{0}) in a \code{bit\_vector}.\\
\begin{tabular}{@{}ll@{}}
\textit{Class}    &\textit{Description} \\
\href{\sdslgit/include/sdsl/bp_support_g.hpp}{\sdslbpsupportg} &
2 level pioneer structure.\\
\href{\sdslgit/include/sdsl/bp_support_gg.hpp}{\sdslbpsupportgg} &
multi level pioneer structure.\\
\href{\sdslgit/include/sdsl/bp_support_sada.hpp}{\sdslbpsupportsada} &
min-max-tree.\\
\end{tabular}
\textit{Public~methods:} \code{find\_open($i$)}, \code{find\_close($i$)},
\code{enclode($i$)}, \code{double\_enclose($i$,$j$)}, \code{excess($i$)},
\code{rr\_enclose($i$,$j$)}, \code{rank($i$)}\footnote{For PBS the
bits are counted in the prefix $[0..i]$.}, \code{select($i$)}.
\\
Call~\code{util::init\_support(bps, bv)}~to initialize a BPS 
\code{bps} to bitvector \code{bv}. 


\subsection{Compressed Suffix Trees (CST)}
\settowidth{\MyLen}{\sdslcstsada\quad}
\begin{tabular}{@{}p{\the\MyLen}%
                @{}p{\linewidth-\the\MyLen}@{}}

\textit{Class} & \textit{Description} \\				
\href{\sdslgit/include/sdsl/cst_sada.hpp}{\sdslcstsada} &
Represents a node as position in BPS. Navigational operations
are fast (they are directly translated in BPS operations on 
the DFS-BPS). Space: $4n\!+\!o(n)\!+\!|CSA|\!+\!|LCP|$ bits.\\
\href{\sdslgit/include/sdsl/cst_sct3.hpp}{\sdslcstsctIII} &
Represents nodes as intervals. Fast construction, but
slower navigational operations. Space: $3n\!+\!o(n)\!+\!|CSA|\!+\!|LCP|$ \\
\end{tabular}
\textit{Public~types:} \code{node\_type}. 
In the following let $v$ and $w$ be nodes 
and $i$, $d$, $lb$, $rb$ integers.\\ 
\textit{Public~methods:} 
 \code{root()}, \code{is\_leaf($v$)}, \code{select\_leaf($i$)},
 \code{size($v$)}, \code{leftmost\_leaf($v$)}, \code{rightmost\_leaf($v$)},
 \code{lb($v$)}, \code{rb($v$)}, \code{parent($v$)}, \code{sibling($v$)},
 \code{select\_child($v$,$i$)}, \code{degree($v$)}, 
 \code{child($v$,$c$)}, \code{edge($v$,$d$)}, \code{lca($v$,$w$)},
 \code{depth($v$)}, \code{node\_depth}, \code{sl($v$)},
 \code{wl($v$,$c$)}, \code{sn($v$)}, \code{id($v$)}, \code{inv\_id($i$)},
 \code{node($lb$,$rb$)}, \code{nodes()}, \code{size()},
 \code{begin()}, \code{end()}, \code{begin\_bottom\_up()},
 \code{end\_bottom\_up}.\\
\textit{Public~members:} \code{csa}, \code{lcp}.

\subsection{Range Min/Max Support (RMS)}
A RMS \code{rms} can be used to determine the position of the miniumum
value\footnote{Or maximum value; can be set by a template parameter.}
in an arbitrary subrange $[i,j]$ of an prepocessed vector \code{v}.
Operator \code{operator($i$,$j$)} returns $x=\min\{$r$\mid r\in [i,j] \wedge \mbox{\code{v}[$r$]}\leq\mbox{\code{v[$k$]}}\ \forall k\in[i,j]\}$

\settowidth{\MyLen}{\sdslrmqsupportsparsetable\quad }
\settowidth{\MidLen}{$4n+o(n)$\quad}
\begin{tabular}{@{}p{\the\MyLen}%
                @{}p{\linewidth-\the\MidLen-\the\MyLen}@{}p{\the\MidLen}@{}}
\textit{Class} & \textit{Space} & \textit{Time} \\				
\href{\sdslgit/include/sdsl/rmq_support_sparse_table.hpp}{\sdslrmqsupportsparsetable} &
$n \log^2 n$ & \Order{1} \\
\href{\sdslgit/include/sdsl/rmq_succinct_sada.hpp}{\sdslrmqsuccinctsada} &
$4n+o(n)$    & \Order{1} \\
\href{\sdslgit/include/sdsl/rmq_succinct_sct.hpp}{\sdslrmqsuccinctsct} &
$2n+o(n)$    & \Order{1} \\
\end{tabular}

\section{Constructing data structures}
Let \code{x} be a WT-, CSA-, or CST-object.
Object \code{x} is built with \code{construct(x,file,num\_bytes=0)}
from a sequence stored in \code{file}. File is interpreted
dependent on the value of \code{num\_bytes}:

\settowidth{\MyLen}{\code{num\_bytes=1}  }
\begin{tabular}{@{}p{\the\MyLen}%
                @{}p{\linewidth-\the\MyLen}@{}}
%\begin{tabular}{@{}ll@{}}
\textit{Value}      & \textit{File interpreted as}  \\
\code{num\_bytes=0} & serialized \code{int\_vector<>}.\\
\code{num\_bytes=1} & byte sequence of length \code{util::file\_size(file)}.\\
\code{num\_bytes=2} & 16-bit word sequence (little endian).\\
\code{num\_bytes=4} & 32-bit word sequence (little endian).\\
\code{num\_bytes=8} & 64-bit word sequence (little endian).\\	
\end{tabular}


\section{Reading and writing data}
\subsection{Importing data into \sdsl\ structures}
\begin{tabular}{@{}p{0.9\linewidth}@{}}
\code{util::load\_vector\_from\_file(v, file, num\_bytes)} \\
Load \code{file} into an \code{int\_vector}~\code{v}. Interpretation
of \code{file} depends on \code{num\_bytes}; see method \code{construct}.
\end{tabular}
TODO: mention io wrappers

\subsection{Load \sdsl\ structures}
\begin{tabular}{@{}p{0.9\linewidth}@{}}
\code{util::load\_from\_file(x, file)} \\
Load an \sdsl\ object \code{x}, which is stored in \code{file}. \\
\code{x.load(in)} \\
Read an \sdsl\ object \code{x} from \code{std::istream}-object \code{in}.\\
\end{tabular}
TODO: mention io wrappers


\subsection{Store \sdsl\ structures}
\begin{tabular}{@{}p{0.9\linewidth}@{}}
\code{util::store\_to\_file(x, file)} \\
Store an \sdsl\ object \code{x} to \code{file}. \\
\code{x.serialize(out)}\\
Write \sdsl\ object \code{x} to \code{std::ostream}-object \code{out}.\\
TODO: add \code{serialize\_vector}	  \\
\end{tabular}


\section{Utility methods}
\code{util::pid()}, 
\code{util::id()}, 
\code{util::to\_string(t)},
\code{util::to\_latex\_string(t)}

\code{util::assign(t1,t2)}
\code{util::clear(t)}
\code{util::swap\_support(s1, s2, t1, t2)}
\code{util::init\_support(s, t)}
\code{util::get\_size\_in\_bytes(t)}
\code{util::write\_member(t, out)}
\code{util::read\_member(t, in)}
\code{util::write\_structure<JSON\_FORMAT>(t, out)} % in IO???

\section{Construction}
\code{util::cache\_file\_name(key, config)}
\code{util::register\_cache\_file(key, config)}
\code{util::cache\_file\_exists(key, config)}
\code{util::load\_from\_cache(t, key, config)}
\code{util::store\_to\_cache(t, key, config)}

\section{Helper}
\code{util::stop\_watch}\\
\textit{Public methods:} \code{start()}, \code{stop()},
\code{user\_time()},  
\code{sys\_time()},
\code{real\_time()},
\code{abs\_user\_time()},
\code{abs\_sys\_time()},
\code{abs\_real\_time()},


\code{paths\_from\_config\_file(file, prefix)}

\section{Performance}
Describe here how many resources are required 
for standard tasks. E.g. construct CSA:
$5n$ bytes peak memory for inputs $<2$ GiB,
$9n$ bytes peak memory for inputs $\geq 2$ GiB.
TODO: insert time space graph for different
construction processes.

TODO: mention benchmarks

\section{Bitmagic}
Let \code{x} be a 64-bit word. Positions in
$x$ start from $0$.
\settowidth{\MyLen}{\code{num\_bytes=1} }
\begin{tabular}{@{}p{\the\MyLen}%
                @{}p{\linewidth-\the\MyLen}@{}}
%\begin{tabular}{@{}ll@{}}
\textit{Method}      & \textit{Description}  \\
\code{b1Cnt(x)}  & Count the number of set bits in \code{x}.\\
\code{i1BP(x,i)} & Get the position of the $i$-th set bit in \code{x},
	$i~\in~[0,\code{b1Cnt(x)}\!-\!1)$.
\end{tabular}

\section{Tests}

Describe here, how to run the tests.

\section{Debugging}
Mention: gdb config file, verbose

\section{Acknowledgements}
Yuta Mori for implementing libdivsufsort, which
is used to construct SAs.

Jesper Larsson for integer-alphabet SA construction.

\rule{0.3\linewidth}{0.25pt}
\scriptsize

\copyright\ Simon Gog

Cheatsheet template provided by Winston Chang
http://www.stdout.org/$\sim$winston/latex/

\end{multicols}
\end{document}
